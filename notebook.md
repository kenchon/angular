# 1.1 JavaScriptの歴史

JavaScriptフレームワークが登場するにいたる歴史的経緯を振り返る。

### JavaScriptの盛り上がり～不遇の時代
- 1990年代，JavaScriptベースのダイナミックHTMLという技術が流行った
	- 画面にアニメーション画像が走る
	- ページ切り替えにエフェクトがかかる
- しかし，これらが過剰に使われ，ページが重かった
- セキュリティホールが見つかったため，かなり限定的な環境じゃないと動かないようになった
- しばらくJavaScriptは不遇の時代を経る

### JavaScriptの復権
- 2005年，**Ajax**が登場した。
	- デスクトップ上で，デスクトップライクなページをつくれる
	- HTML，JavaScriptという標準的な技術でリッチなコンテンツが作れる
- ECMAによる標準化もあって，JavaScriptの見直しが図られた
- 2000年代後半にHTML5が登場，JavaScript APIが強化されていく
### JavaScriptライブラリから，JavaScriptフレームワークへ
- JavaScriptは生産性が高い言語とは言えない
	- ブラウザによって挙動が異なる問題
	- 特有の癖：プロトタイプベースと呼ばれる特殊なオブジェクト指向構文
	- 型の制約が緩い
- jQueryが一世を風靡，UI開発が容易になる。ただし，大規模開発は苦手
	- あくまでページ操作をサポートするライブラリである。例えば，見た目とビジネスロジックを明確に分離するようなアプリの構造化はできない。
➡ **以上の経緯から，大規模開発に向いた本格的なフレームワークが求められてきた**

# 1.2 フレームワークとは？
- フレームワークとは
>問題に対する定石（イディオム），または設計面での方法論を「再利用可能なクラス」という形でまとめたもの。
>言い換えると，アプリのコードを相互につなげるベース

- アプリ開発者は，フレームワークの基盤に沿って独自のコードを加えることで，一定の品質をもったアプリを作ることができる
- ライブラリとフレームワークはどう違うの？
	- **ライブラリ**：ユーザコードによって呼び出される。
	- **フレームワーク**：ユーザコードを呼び出す。
	- 後者は，アプリのライフサイクル（初期化から実処理，終了までの流れ）を管理しており，その要所要所で「なにをすべきか」をユーザコードに問い合わせる

## フレームワーク導入の利点
 - 開発生産性の向上
	- 同じルールを強制する。一貫性が保たれる
	- ユーザコードは機能ごとに相互に独立しているので，機能単位での役割分担をしやすく，大規模開発に向いている
- メンテナンス性に優れる
	- アプリの可読性が高い。問題個所の特定がしやすい
	- 同一のアーキテクチャを採用していれば，統合なども楽になる
	- 開発ノウハウを容易に引き継げる
- 先端の技術トレンドにも対応しやすい
	- フレームワークは日々更新される
	- セキュリティにも対応してくれる
- 一定以上の品質が期待できる
	- 自作アプリより「信頼性が高い」
	- 利用実績が長い
	- フレームワークを用いるということは，現在のベストプラクティスを導入するということ

## なぜAngularか
- 現時点でもっとも注目されるフレームワークのひとつである
- Googleが開発に携わっており，継続的なバージョンアップが期待できる
> ”人気やシェアは，フレームワークとしての良しあしを左右する決定的な基準ではありませんが，重要な要素ではあります。というのも，シェアの大きさは，様々なユーザの目にさらされ，実績を積み，支援されていることの証であり，そのまま「品質の高さ」「資料の豊富さ」「実績の蓄積」を物語っているからです”

## Angularの特徴
- フルスタックのフレームワーク
	- HTMLベースのテンプレートエンジン
	- ビジネスロジックを実装するためのサービス
	- URLに応じてページを振り分けるルーティング機能
	- 単体テスト・シナリオテストを支援するテストフレームワーク
	- など
- コンポーネント指向
	- コンポーネントは画面に複数配置できるし，階層構造にも出来る
	- Angularアプリとは，１つ以上のコンポーネントの集合である
	- コンポーネントは，ビュー，クラス，メタ情報の複合体
- JSの派生言語をサポートしているものの，TypeScriptで開発するのが無難
- Angularバージョンポリシー
	- バージョン番号は，「`メジャーバージョン`.`マイナーバージョン`.`パッチ`」で表現
	- パッチ：バグフィックスなどの微小な変更
	- マイナーバージョン：機能追加を伴うが，互換性は保たれる
	- メジャーバージョン：互換性が保たれないことがある破壊的な変更
- Angularは半年に一度バージョンアップする

## Angularアプリの構成部品：モジュール
### モジュールとは
- 関連するクラスをまとめて，モジュールとして扱う
	- **Angularアプリ**
		- `ルートモジュール`
			- コンポーネント，UI部品
			- サービス，ビジネスロジック
			- パイプ
			- ディレクティブ
		- `サブモジュール`
			- コンポーネント
			- サービス
		- `Angularモジュール`
			- Common Module
			- Http Module ...
			
	- アノテーション`@`：クラスを定義しただけでは，モジュールとはみなされない。`@NgModule`デコレータ―でモジュールとしての情報を宣言する必要がある。**デコレータ**とは，クラスやプロパティ，メソッド，引数などに対して，構成情報を付与するためのしくみ。

### サンプルアプリに含まれる構成物
- `app.component.ts`: ページを構成するUI部品を記述するコード
- `main.ts`: Angularアプリを起動するためのスタートアップコード
- `index.html`: メインページを準備する
- 設定ファイル:
	- `package.json`: Angular，またはアプリ本体で利用するライブラリ情報などを定義
	- `tsconfig.json`: TypeScriptコンパイラの動作を定義
	- `systemjs.config.js`: モジュールローダー(SystemJS)の設定情報
		- 呼び出したファイルの拡張子を省略したときの挙動の記述
		- `baseURL`などの設定

# 3. データバインディング
データバインディングとは？
>Angularアプリで画面（コンポーネント）を制御するうえで欠かせない仕組み。データバインディングを使用することで，コンポーネントの値をテンプレートに反映したり，テンプレートの変化をコンポーネントに伝達したり，といった仕掛けを限りなくコーディングレスで実装できます。

言い換えると，コンポーネントとテンプレート（ビュー）とを紐づけるための仕組み。

データバインディング構文

| データの方向 | 種類        | 記法 |
|--   |--                  |--          |
| C→V | Interpolation(補間) | `{{...}}` |
| C→V |プロパティ・属性バインディング|`[property]="value"`|
| C←V |イベントバインディング|`(event)="handler"`|
| C⇔V |双方向バインディング|`[(target)]="value"`|

ポイント：**バインド方式によって記法が異なる**

## 3.2 Interpolation構文

### ・`{{...}}`式
- テンプレートに埋め込む値を，コンポーネントのプロパティとして定義する
例：①で定義した`name`プロパティを②で`{{name}}`として参照する
```javascript
import { Component } from  '@angular/core';
@Component({
	selector:  'my-app',
	template:  `<h1>Hello {{name}}</h1>`, //②
})
export  class  AppComponent { name  =  'Angular'; } //①
```

補間の中身では，JavaScriptの構文が使える。ただし，以下の点に注意：
- 式が副作用を伴わない；ほかの値に影響が出ない
- 短時間で実行できる
- シンプルである
- 冪等である；同じ操作を繰り返して実行しても同じ結果を返す

`{{...}}`は何度も繰り返されるので，アプリが重くなる原因になることを避ける。

### ・`?.`演算子(Safe Navigation Operator)
```javascript
import { Component } from  '@angular/core';
@Component({
	selector:  'my-app',
	template:  `<h1>Hello {{member.name}}</h1>`, //①
})
export  class  AppComponent { 
	member = {
		name = '山田太郎',
		age = 30
	};
}
```
`member`プロパティをコメントアウトした状態で，これを実行すると，①で例外が発生する。
例外に対処するためには，nglfディレクティブを使って，あらかじめundefined/nullチェックを行えばよいが，コードが冗長になってしまう。ここで，①を次のように書き換えると，例外が発生しなくなる。
```javascript
	template:  `<h1>Hello {{member?.name}}</h1>`, //①'
```
これによって，オブジェクト`member`が空であるかどうかを確認し，から出ない場合のみに`name`プロパティにアクセスするので「安全」である。

## 3.3 プロパティバインディング
プロパティバインディングによって，要素のプロパティに対して値をバインドできる。
要素とは，例えばHTML要素などがある。

```javascript
import { Component } from  '@angular/core';
@Component({
	selector:  'my-app',
	//ブラケット構文
	template:  `<img [src]="image" />` //①
	//bind-xxxxx属性
	//template: `<img bind-src="image" />`　//②
	//Interpolation
	//template: `<img src="{{image}}" />` //③
})
export  class  AppComponent {
	image  =  'http://www.wings.msn.to/image/wings.jpg';
}
```
①では，`"image"`は文字列ではなく，プロパティを表す変数となる。
他にも，②，③などの書き方があるが，プロジェクトで統一するのが良い。

